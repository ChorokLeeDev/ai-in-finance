"""
======================================================================================
Week 1: GNN (Graph Neural Network) ê¸°ì´ˆ í•™ìŠµ
======================================================================================

ğŸ“š ì´ ì½”ë“œê°€ í•˜ëŠ” ì¼:
    Cora ë…¼ë¬¸ ì¸ìš© ê·¸ë˜í”„ì—ì„œ ë…¼ë¬¸ì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ë¶„ë¥˜í•˜ëŠ” GNN ëª¨ë¸ì„ í•™ìŠµí•©ë‹ˆë‹¤.

    ë°ì´í„°: 2708ê°œ ë…¼ë¬¸, 5429ê°œ ì¸ìš© ê´€ê³„, 7ê°œ ì¹´í…Œê³ ë¦¬
    ëª©í‘œ: ë…¼ë¬¸ì˜ ë‚´ìš©(ë‹¨ì–´)ê³¼ ì¸ìš© ê´€ê³„(ê·¸ë˜í”„ êµ¬ì¡°)ë¥¼ í™œìš©í•´ ì¹´í…Œê³ ë¦¬ ì˜ˆì¸¡

======================================================================================
ğŸ”‘ í•µì‹¬ ê°œë… 1: ì°¨ì› ë³€í™˜ (Feature Transformation)
======================================================================================

Q: ê°€ì¤‘ì¹˜ ë³€í™˜ í–‰ë ¬ì´ ë­”ê°€ìš”?
A: ì…ë ¥ ì°¨ì›ì„ ì¶œë ¥ ì°¨ì›ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•™ìŠµ ê°€ëŠ¥í•œ í–‰ë ¬ì…ë‹ˆë‹¤.

ì˜ˆì‹œ:
    ë…¼ë¬¸ 1ê°œ ì›ë³¸ ë°ì´í„° (1433ì°¨ì›):
    [0, 5, 0, 3, 0, 0, 4, 2, 0, 1, 0, ...]
     â†‘  â†‘  â†‘  â†‘  â†‘  â†‘  â†‘  â†‘  â†‘  â†‘
    ê° ìœ„ì¹˜ = íŠ¹ì • ë‹¨ì–´ê°€ ë…¼ë¬¸ì— ë“±ì¥í•œ íšŸìˆ˜
    (ì˜ˆ: "neural"=5ë²ˆ, "learning"=3ë²ˆ, "deep"=4ë²ˆ)

    ë¬¸ì œ: 1433ê°œëŠ” ë„ˆë¬´ ë§ê³ , ëŒ€ë¶€ë¶„ ì˜ë¯¸ì—†ëŠ” ë‹¨ì–´ë“¤!

    í•´ê²°: nn.Linear(1433, 16) - ê°€ì¤‘ì¹˜ í–‰ë ¬ë¡œ ë³€í™˜

    ì••ì¶•ëœ 16ì°¨ì› íŠ¹ì§•:
    [0.9, 0.1, 0.1, 0.8, 0.6, 0.2, ...]
     â†‘    â†‘    â†‘    â†‘    â†‘    â†‘
     AI   ìƒë¬¼  ë¬¼ë¦¬  ì´ë¡   ìµœì‹   ìˆ˜í•™
     ê´€ë ¨ ê´€ë ¨  ê´€ë ¨  ì„±    ì„±    ì„±

    â†’ ëª¨ë¸ì´ ìë™ìœ¼ë¡œ "ì–´ë–¤ ë‹¨ì–´ ì¡°í•©ì´ ì–´ë–¤ ì˜ë¯¸ì¸ì§€" í•™ìŠµ!

ë³€í™˜ ê³¼ì •:
    1. ì…ë ¥: [1433ì°¨ì›] - êµ¬ì²´ì  ë‹¨ì–´ ë¹ˆë„
       â†“ conv1_weight (í•™ìŠµ ê°€ëŠ¥í•œ 1433x16 í–‰ë ¬)

    2. ì€ë‹‰: [16ì°¨ì›] - ì¶”ìƒì  íŠ¹ì§• (AIì •ë„, ìƒë¬¼ì •ë„, ì´ë¡ ì„± ë“±)
       â†“ conv2_weight (í•™ìŠµ ê°€ëŠ¥í•œ 16x7 í–‰ë ¬)

    3. ì¶œë ¥: [7ì°¨ì›] - ê° ì¹´í…Œê³ ë¦¬ ì ìˆ˜
       â†“ argmax

    4. ì˜ˆì¸¡: [1ê°œ ìˆ«ì] - ìµœì¢… ì¹´í…Œê³ ë¦¬

======================================================================================
ğŸ”‘ í•µì‹¬ ê°œë… 2: Message Passing (ì´ì›ƒ ì§‘ê³„)
======================================================================================

Q: ê·¸ë˜í”„ êµ¬ì¡°ë¥¼ ì–´ë–»ê²Œ í™œìš©í•˜ë‚˜ìš”?
A: Message Passing - ê° ë…¸ë“œê°€ ì´ì›ƒ ë…¸ë“œë“¤ì˜ ì •ë³´ë¥¼ ëª¨ì•„ì„œ ìì‹ ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

ì¼ë°˜ ì‹ ê²½ë§ vs GNN:
    ì¼ë°˜ ì‹ ê²½ë§:
        ê° ë°ì´í„°ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì²˜ë¦¬
        ë…¼ë¬¸1 â†’ [íŠ¹ì„± ë³€í™˜] â†’ ì˜ˆì¸¡1
        ë…¼ë¬¸2 â†’ [íŠ¹ì„± ë³€í™˜] â†’ ì˜ˆì¸¡2
        (ì„œë¡œ ì˜í–¥ ì—†ìŒ)

    GNN:
        ê·¸ë˜í”„ êµ¬ì¡°ë¥¼ í™œìš©í•´ ì´ì›ƒì˜ ì •ë³´ë„ í•¨ê»˜ ì‚¬ìš©
        ë…¼ë¬¸1 â† ì¸ìš© ê´€ê³„ â†’ ë…¼ë¬¸2, ë…¼ë¬¸3
        "ë…¼ë¬¸1ì„ ì¸ìš©í•œ ë…¼ë¬¸ë“¤ì´ AI ë…¼ë¬¸ì´ë©´, ë…¼ë¬¸1ë„ AI ë…¼ë¬¸ì¼ ê°€ëŠ¥ì„± ë†’ë‹¤!"

Message Passing ê³¼ì •:
    ì˜ˆì‹œ: ë…¸ë“œ Aê°€ ë…¸ë“œ B, C, Dì™€ ì—°ê²°ë¨

    Step 1: ê° ë…¸ë“œì˜ íŠ¹ì„± ë³€í™˜
        A: [0.5, 0.3, 0.2]
        B: [0.1, 0.8, 0.1]  â† Aì˜ ì´ì›ƒ
        C: [0.2, 0.7, 0.1]  â† Aì˜ ì´ì›ƒ
        D: [0.3, 0.6, 0.1]  â† Aì˜ ì´ì›ƒ

    Step 2: ì´ì›ƒë“¤ì˜ íŠ¹ì„± í‰ê·  ê³„ì‚°
        í‰ê·  = (B + C + D) / 3
             = [(0.1+0.2+0.3)/3, (0.8+0.7+0.6)/3, (0.1+0.1+0.1)/3]
             = [0.2, 0.7, 0.1]

    Step 3: Aì˜ ìƒˆ íŠ¹ì„± = ì´ì›ƒë“¤ì˜ í‰ê· 
        A_new = [0.2, 0.7, 0.1]

    â†’ AëŠ” ì´ì›ƒ B, C, Dì˜ ì •ë³´ë¥¼ ë°˜ì˜í•˜ê²Œ ë¨!

ì™œ í‰ê· ì„ ë‚´ë‚˜?
    - ì´ì›ƒì´ ë§ì€ ë…¸ë“œì™€ ì ì€ ë…¸ë“œë¥¼ ê³µì •í•˜ê²Œ ì²˜ë¦¬í•˜ê¸° ìœ„í•¨
    - ì´ì›ƒì´ 100ê°œë©´ 100ê°œ í•©, ì´ì›ƒì´ 2ê°œë©´ 2ê°œ í•© â†’ ë¶ˆê³µí‰!
    - í‰ê· ì„ ë‚´ë©´ ì´ì›ƒ ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ ê°™ì€ ìŠ¤ì¼€ì¼ ìœ ì§€

======================================================================================
ğŸ”‘ í•µì‹¬ ê°œë… 3: í•™ìŠµ ê³¼ì •
======================================================================================

Q: ëª¨ë¸ì´ ì–´ë–»ê²Œ í•™ìŠµí•˜ë‚˜ìš”?
A: ì†ì‹¤(loss)ì„ ìµœì†Œí™”í•˜ëŠ” ë°©í–¥ìœ¼ë¡œ ê°€ì¤‘ì¹˜ë¥¼ ë°˜ë³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

í•™ìŠµ ë£¨í”„ (ë§¤ ì—í­ë§ˆë‹¤):
    1. optimizer.zero_grad()
       â†’ ì´ì „ ê¸°ìš¸ê¸° ì´ˆê¸°í™” (ì•ˆí•˜ë©´ ëˆ„ì ë¨)

    2. out = model(x, edge_index)
       â†’ ìˆœì „íŒŒ: ì˜ˆì¸¡ê°’ ê³„ì‚°

    3. loss = criterion(out, y)
       â†’ ì†ì‹¤ ê³„ì‚°: ì˜ˆì¸¡ê³¼ ì •ë‹µì˜ ì°¨ì´

    4. loss.backward()
       â†’ ì—­ì „íŒŒ: ê° ê°€ì¤‘ì¹˜ê°€ ì†ì‹¤ì— ë¯¸ì¹œ ì˜í–¥ ê³„ì‚°

    5. optimizer.step()
       â†’ ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸: ì†ì‹¤ì„ ì¤„ì´ëŠ” ë°©í–¥ìœ¼ë¡œ ì¡°ê¸ˆì”© ì´ë™

ì˜ˆì‹œ:
    ì´ˆê¸° ê°€ì¤‘ì¹˜ (ëœë¤):
        W = [[0.1, 0.2, ...],
             [0.3, 0.1, ...]]
        â†’ ì˜ˆì¸¡ì´ ì—‰ë§

    100 ì—í­ í›„:
        W = [[0.85, 0.02, ...],   â† "neural" ë‹¨ì–´ê°€ ë§ìœ¼ë©´
             [0.78, 0.03, ...]]      AI ì¹´í…Œê³ ë¦¬ ì ìˆ˜ ë†’ì„!
        â†’ ì˜ˆì¸¡ì´ ì •í™•í•´ì§

======================================================================================
â“ ìì£¼ ë¬»ëŠ” ì§ˆë¬¸ (FAQ)
======================================================================================

Q1: ì™œ ë ˆì´ì–´ë¥¼ 2ê°œ ë§Œë“œë‚˜ìš”?
    A: 2-layer = 2-hop ì´ì›ƒê¹Œì§€ ì •ë³´ ë„ë‹¬ (Coraì—ì„œ ê²½í—˜ì ìœ¼ë¡œ ìµœì )
       í•˜ì§€ë§Œ í•˜ì´í¼íŒŒë¼ë¯¸í„°! ë°ì´í„°ë§ˆë‹¤ 1, 3, 4-layer ë“± ì‹¤í—˜ í•„ìš”

Q2: ì™œ ReLUë¥¼ ì¤‘ê°„ì—ë§Œ ë„£ë‚˜ìš”?
    A: 1) ë¹„ì„ í˜•ì„± ì¶”ê°€ - ReLU ì—†ìœ¼ë©´ 2-layerê°€ 1-layerì™€ ë™ì¼í•´ì§
       2) ë§ˆì§€ë§‰ ì¶œë ¥ì€ ìŒìˆ˜ë„ í•„ìš” - CrossEntropyLossê°€ ìŒìˆ˜ ì ìˆ˜ë„ ì‚¬ìš©

Q3: ì™œ __init__ì—ì„œ ë ˆì´ì–´ë¥¼ ì´ˆê¸°í™”í•˜ë‚˜ìš”?
    A: PyTorch íŒ¨í„´ - í•™ìŠµ ê°€ëŠ¥í•œ íŒŒë¼ë¯¸í„°ëŠ” __init__ì—ì„œ ìƒì„±
       (model.parameters()ë¡œ ì°¾ì„ ìˆ˜ ìˆë„ë¡)

Q4: ì™œ forwardì—ì„œ ì¡°ë¦½í•˜ë‚˜ìš”?
    A: ì‹¤ì œ ë°ì´í„° íë¦„ì„ ì •ì˜ - ê°™ì€ ë ˆì´ì–´ë¥¼ ë‹¤ë¥¸ ìˆœì„œë¡œ ì¡°í•© ê°€ëŠ¥ (ìœ ì—°ì„±)

Q5: CrossEntropyLossê°€ ë­”ê°€ìš”?
    A: ì˜ˆì¸¡ê³¼ ì •ë‹µì˜ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ëŠ” ì†ì‹¤ í•¨ìˆ˜
       Loss = -log(ì •ë‹µ ì¹´í…Œê³ ë¦¬ì˜ í™•ë¥ )
       ì˜ˆì¸¡ ì˜í•¨: í™•ë¥  0.9 â†’ Loss = 0.105 (ì‘ìŒ)
       ì˜ˆì¸¡ í‹€ë¦¼: í™•ë¥  0.1 â†’ Loss = 2.303 (í¼)

======================================================================================
"""

# PyTorch ê¸°ë³¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ - í…ì„œ ì—°ì‚°ê³¼ ë”¥ëŸ¬ë‹ì˜ ê¸°ì´ˆ
import torch

# PyTorchì˜ ì‹ ê²½ë§ ëª¨ë“ˆ - ë ˆì´ì–´, ì†ì‹¤í•¨ìˆ˜ ë“±ì„ ì œê³µ
import torch.nn as nn

# PyTorch Geometricì˜ ë°ì´í„° êµ¬ì¡° - ê·¸ë˜í”„ ë°ì´í„°ë¥¼ í‘œí˜„ (í˜„ì¬ ì‚¬ìš© ì•ˆí•¨)
from torch_geometric.data import Data

# Planetoid ë°ì´í„°ì…‹ ë¡œë” - Cora, Citeseer, Pubmed ê°™ì€ ì¸ìš© ë„¤íŠ¸ì›Œí¬ ë°ì´í„°ì…‹
from torch_geometric.datasets import Planetoid

# GCN(Graph Convolutional Network) ë ˆì´ì–´ - PyGì—ì„œ ì œê³µí•˜ëŠ” ê·¸ë˜í”„ í•©ì„±ê³±
from torch_geometric.nn import GCNConv


class SimpleGNN(nn.Module):
    """
    ê°€ì¥ ê¸°ë³¸ì ì¸ Graph Convolutionì„ ì§ì ‘ êµ¬í˜„
    ëª©ì : Message passingì˜ ì›ë¦¬ë¥¼ ì™„ì „íˆ ì´í•´
    """

    def __init__(self, in_channels, hidden_channels, out_channels):
        # ë¶€ëª¨ í´ë˜ìŠ¤(nn.Module) ì´ˆê¸°í™” - PyTorch ëª¨ë¸ì˜ í•„ìˆ˜ ë‹¨ê³„
        super().__init__()

        # ì²« ë²ˆì§¸ GNN ë ˆì´ì–´ì˜ ê°€ì¤‘ì¹˜ ë³€í™˜ í–‰ë ¬ (ì…ë ¥ -> ì€ë‹‰ì¸µ)
        # in_channels: ì…ë ¥ íŠ¹ì„± ì°¨ì› (CoraëŠ” 1433ì°¨ì› - ë‹¨ì–´ ë¹ˆë„)
        # hidden_channels: ì€ë‹‰ì¸µ ì°¨ì› (ë³´í†µ 16~64)
        self.conv1_weight = nn.Linear(in_channels, hidden_channels)

        # ë‘ ë²ˆì§¸ GNN ë ˆì´ì–´ì˜ ê°€ì¤‘ì¹˜ ë³€í™˜ í–‰ë ¬ (ì€ë‹‰ì¸µ -> ì¶œë ¥)
        # out_channels: ì¶œë ¥ í´ë˜ìŠ¤ ê°œìˆ˜ (CoraëŠ” 7ê°œ ì¹´í…Œê³ ë¦¬)
        self.conv2_weight = nn.Linear(hidden_channels, out_channels)

    def forward(self, x, edge_index):
        # forward í•¨ìˆ˜: ìˆœì „íŒŒ(ì˜ˆì¸¡) ê³¼ì •ì„ ì •ì˜
        # x: ë…¸ë“œ íŠ¹ì„± í–‰ë ¬ (num_nodes, in_channels) - ê° ë…¸ë“œì˜ íŠ¹ì§• ë²¡í„°
        # edge_index: ì—£ì§€ ì¸ë±ìŠ¤ (2, num_edges) - ê·¸ë˜í”„ êµ¬ì¡°ë¥¼ í‘œí˜„ [ì¶œë°œë…¸ë“œ, ë„ì°©ë…¸ë“œ]

        # === Layer 1: Transform + Aggregate + Activate ===

        # Step 1: íŠ¹ì„± ë³€í™˜ - ê° ë…¸ë“œì˜ íŠ¹ì„±ì„ ê°€ì¤‘ì¹˜ í–‰ë ¬ë¡œ ë³€í™˜
        x = self.conv1_weight(x)  # (N, hidden) - ì„ í˜• ë³€í™˜ ì ìš©

        # Step 2: ì´ì›ƒ ì§‘ê³„ (í•µì‹¬!) - ê·¸ë˜í”„ êµ¬ì¡°ë¥¼ í™œìš©í•´ ì´ì›ƒë“¤ì˜ ì •ë³´ë¥¼ ëª¨ìŒ
        x = self.aggregate(x, edge_index)  # Message passing - ì´ì›ƒ ë…¸ë“œë“¤ì˜ í‰ê· 

        # Step 3: ë¹„ì„ í˜• í™œì„±í™” - ReLUë¡œ ë¹„ì„ í˜•ì„± ì¶”ê°€ (0 ë¯¸ë§Œ ê°’ì€ 0ìœ¼ë¡œ)
        # ì¤‘ê°„ ë ˆì´ì–´ì—ë§Œ ì‚¬ìš©! (ë¹„ì„ í˜•ì„± ì¶”ê°€)
        x = torch.relu(x)

        # === Layer 2: ë™ì¼í•œ ê³¼ì • ë°˜ë³µ (í™œì„±í™” ì—†ì´ ì¶œë ¥) ===

        # ë‘ ë²ˆì§¸ íŠ¹ì„± ë³€í™˜
        x = self.conv2_weight(x)

        # ë‘ ë²ˆì§¸ ì´ì›ƒ ì§‘ê³„ - 2-hop ì´ì›ƒê¹Œì§€ ì •ë³´ê°€ ì „ë‹¬ë¨
        x = self.aggregate(x, edge_index)

        # ìµœì¢… ì¶œë ¥ ë°˜í™˜ - ê° ë…¸ë“œì˜ í´ë˜ìŠ¤ ì ìˆ˜ ë¡œì§“ (logits)
        # ë§ˆì§€ë§‰ì€ ReLU ì—†ìŒ! ì´ìœ :
        # 1) ìŒìˆ˜ ì ìˆ˜ë„ ì¤‘ìš”: -1.3 = "ì´ ì¹´í…Œê³ ë¦¬ ì•„ë‹˜"
        # 2) CrossEntropyLossê°€ ìŒìˆ˜ë¥¼ ì‚¬ìš©: exp(-1.3) = ì‘ì€ í™•ë¥ 
        # 3) ReLU ì“°ë©´ ìŒìˆ˜â†’0 ë³€í™˜ìœ¼ë¡œ ì •ë³´ ì†ì‹¤!
        return x

    def aggregate(self, x, edge_index):
        """
        ==================================================================================
        í•µì‹¬: Message Passing êµ¬í˜„
        ==================================================================================

        ê° ë…¸ë“œëŠ” ì´ì›ƒë“¤ì˜ featureë¥¼ í‰ê· ë‚´ì„œ ìì‹ ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        GNNì˜ í•µì‹¬ ì•„ì´ë””ì–´: ì´ì›ƒ ë…¸ë“œë“¤ì˜ ì •ë³´ë¥¼ ëª¨ì•„ì„œ ìì‹ ì„ ì—…ë°ì´íŠ¸

        ==================================================================================
        ğŸ“Š êµ¬ì²´ì ì¸ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°
        ==================================================================================

        ê°„ë‹¨í•œ ê·¸ë˜í”„:
            ë…¸ë“œ 0 (AI ë…¼ë¬¸)
              â†“ ì¸ìš©
            ë…¸ë“œ 1 (AI ë…¼ë¬¸)  â†’  ë…¸ë“œ 2 (ìƒë¬¼ ë…¼ë¬¸)

        ê° ë…¸ë“œì˜ íŠ¹ì„± (2ì°¨ì›ìœ¼ë¡œ ë‹¨ìˆœí™”):
            ë…¸ë“œ 0: [0.9, 0.1]  (AI=0.9, ìƒë¬¼=0.1)
            ë…¸ë“œ 1: [0.8, 0.2]  (AI=0.8, ìƒë¬¼=0.2)
            ë…¸ë“œ 2: [0.1, 0.9]  (AI=0.1, ìƒë¬¼=0.9)

        edge_index (ì¸ìš© ê´€ê³„):
            [[0, 1],     â† source (ì¶œë°œ): 0â†’1, 1â†’2
             [1, 2]]     â† target (ë„ì°©)

        ëª©í‘œ: ê° ë…¸ë“œê°€ ìì‹ ì„ ì¸ìš©í•œ ë…¼ë¬¸ë“¤ì˜ ì •ë³´ë¥¼ ë°›ì•„ì„œ ì—…ë°ì´íŠ¸

        ==================================================================================
        Step 1: ê° ë…¸ë“œì˜ ì°¨ìˆ˜(degree) ê³„ì‚°
        ==================================================================================

        ì°¨ìˆ˜ = ê° ë…¸ë“œê°€ ëª‡ ê°œì˜ ë©”ì‹œì§€ë¥¼ ë°›ëŠ”ì§€

        row = [0, 1]  â† ë©”ì‹œì§€ ë³´ë‚´ëŠ” ë…¸ë“œ
        col = [1, 2]  â† ë©”ì‹œì§€ ë°›ëŠ” ë…¸ë“œ

        bincount(row):
            ë…¸ë“œ 0: 1ë²ˆ ë“±ì¥ â†’ ë…¸ë“œ 0ì€ 1ê°œì˜ ë©”ì‹œì§€ ë³´ëƒ„
            ë…¸ë“œ 1: 1ë²ˆ ë“±ì¥ â†’ ë…¸ë“œ 1ì€ 1ê°œì˜ ë©”ì‹œì§€ ë³´ëƒ„
            ë…¸ë“œ 2: 0ë²ˆ ë“±ì¥ â†’ ë…¸ë“œ 2ëŠ” ë©”ì‹œì§€ ì•ˆ ë³´ëƒ„

        deg = [1, 1, 0]

        deg_inv (í‰ê· ì„ ìœ„í•œ ì—­ìˆ˜):
            deg_inv = [1/1, 1/1, 1/0] = [1.0, 1.0, inf]

        infë¥¼ 0ìœ¼ë¡œ ì²˜ë¦¬:
            deg_inv = [1.0, 1.0, 0.0]

        ==================================================================================
        Step 2: ë©”ì‹œì§€ ì „ë‹¬ (Message Passing)
        ==================================================================================

        ì´ˆê¸° ìƒíƒœ:
            out = [[0.0, 0.0],  â† ë…¸ë“œ 0
                   [0.0, 0.0],  â† ë…¸ë“œ 1
                   [0.0, 0.0]]  â† ë…¸ë“œ 2

        ì—£ì§€ë³„ë¡œ ìˆœíšŒ:

        1) ì—£ì§€ 0â†’1:
            src=0, dst=1
            out[1] += x[0] * deg_inv[1]
            out[1] += [0.9, 0.1] * 1.0
            out[1] = [0.9, 0.1]

            ì˜ë¯¸: "ë…¸ë“œ 1ì€ ë…¸ë“œ 0(AI ë…¼ë¬¸)ì˜ ì •ë³´ë¥¼ ë°›ì•˜ë‹¤"

        2) ì—£ì§€ 1â†’2:
            src=1, dst=2
            out[2] += x[1] * deg_inv[2]
            out[2] += [0.8, 0.2] * 1.0
            out[2] = [0.8, 0.2]

            ì˜ë¯¸: "ë…¸ë“œ 2ëŠ” ë…¸ë“œ 1(AI ë…¼ë¬¸)ì˜ ì •ë³´ë¥¼ ë°›ì•˜ë‹¤"

        ìµœì¢… ê²°ê³¼:
            out = [[0.0, 0.0],  â† ë…¸ë“œ 0: ì•„ë¬´ë„ ì•ˆ ì¸ìš© (ë©”ì‹œì§€ ì—†ìŒ)
                   [0.9, 0.1],  â† ë…¸ë“œ 1: ë…¸ë“œ 0ì˜ ì •ë³´ ë°›ìŒ (AI ì„±í–¥)
                   [0.8, 0.2]]  â† ë…¸ë“œ 2: ë…¸ë“œ 1ì˜ ì •ë³´ ë°›ìŒ (AI ì„±í–¥)

        í•´ì„:
            - ë…¸ë“œ 2ëŠ” ì›ë˜ ìƒë¬¼ ë…¼ë¬¸ [0.1, 0.9]ì´ì—ˆì§€ë§Œ
            - AI ë…¼ë¬¸(ë…¸ë“œ 1)ì´ ìì‹ ì„ ì¸ìš©í–ˆë‹¤ëŠ” ì •ë³´ë¥¼ ë°›ì•„ì„œ
            - AI ì„±í–¥ [0.8, 0.2]ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë¨!
            - "ë‚˜ë¥¼ ì¸ìš©í•œ ë…¼ë¬¸ì´ AIë©´, ë‚˜ë„ AIì¼ ê°€ëŠ¥ì„± ë†’ë‹¤" ë°˜ì˜!

        ==================================================================================
        ğŸ’¡ ì™œ í‰ê· (deg_inv)ì„ ì‚¬ìš©í•˜ë‚˜?
        ==================================================================================

        í‰ê·  ì•ˆ ì“°ë©´:
            ë…¸ë“œ A: ì´ì›ƒ 1ê°œ  â†’ í•© = 1
            ë…¸ë“œ B: ì´ì›ƒ 100ê°œ â†’ í•© = 100
            ë¬¸ì œ: ë…¸ë“œ Bê°€ ì¸ìœ„ì ìœ¼ë¡œ 100ë°° í° ê°’ì„ ê°€ì§ (ë¶ˆê³µí‰!)

        í‰ê·  ì“°ë©´:
            ë…¸ë“œ A: í•© / 1 = 1
            ë…¸ë“œ B: í•© / 100 = 1
            í•´ê²°: ì´ì›ƒ ìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ ê°™ì€ ìŠ¤ì¼€ì¼ ìœ ì§€!

        ==================================================================================
        """
        # edge_index[0]: source nodes (ë©”ì‹œì§€ë¥¼ ë³´ë‚´ëŠ” ë…¸ë“œ)
        # edge_index[1]: target nodes (ë©”ì‹œì§€ë¥¼ ë°›ëŠ” ë…¸ë“œ)

        # === Step 1: ì •ê·œí™”ë¥¼ ìœ„í•œ ë…¸ë“œ ì°¨ìˆ˜(degree) ê³„ì‚° ===

        # row: ì¶œë°œ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸, col: ë„ì°© ë…¸ë“œ ë¦¬ìŠ¤íŠ¸
        row, col = edge_index

        # deg: ê° ë…¸ë“œê°€ ëª‡ ê°œì˜ ì´ì›ƒì„ ê°€ì§€ëŠ”ì§€ ê³„ì‚° (ì°¨ìˆ˜)
        # bincountë¡œ ê° ë…¸ë“œ IDì˜ ë“±ì¥ íšŸìˆ˜ë¥¼ ì„¸ì„œ ì°¨ìˆ˜ë¥¼ êµ¬í•¨
        deg = torch.bincount(row, minlength=x.size(0)).float()

        # deg_inv: ì°¨ìˆ˜ì˜ ì—­ìˆ˜ - í‰ê· ì„ êµ¬í•˜ê¸° ìœ„í•¨ (1/ì´ì›ƒìˆ˜)
        deg_inv = 1.0 / deg

        # ê³ ë¦½ ë…¸ë“œ(ì°¨ìˆ˜=0) ì²˜ë¦¬ - 1/0=infë¥¼ 0ìœ¼ë¡œ ë³€ê²½í•´ ì—ëŸ¬ ë°©ì§€
        deg_inv[deg_inv == float('inf')] = 0

        # === Step 2: ì´ì›ƒë“¤ë¡œë¶€í„° ë©”ì‹œì§€ ì§‘ê³„ ===

        # out: ì§‘ê³„ ê²°ê³¼ë¥¼ ì €ì¥í•  í…ì„œ (xì™€ ê°™ì€ í¬ê¸°ë¡œ 0ìœ¼ë¡œ ì´ˆê¸°í™”)
        # zeros_like = xì™€ ê°™ì€ í˜•íƒœ(shape)ì˜ 0ìœ¼ë¡œ ì±„ì›Œì§„ í…ì„œ ìƒì„±
        # ì˜ˆ: xê°€ (3, 2)ë©´ outë„ (3, 2) í¬ê¸°ì˜ 0 í…ì„œ
        out = torch.zeros_like(x)

        # ëª¨ë“  ì—£ì§€ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ë©”ì‹œì§€ ì „ë‹¬
        # zip(row, col): ì¶œë°œ ë…¸ë“œì™€ ë„ì°© ë…¸ë“œë¥¼ ìŒìœ¼ë¡œ ë¬¶ì–´ì„œ ë°˜ë³µ
        # ì˜ˆ: row=[0,1], col=[1,2] â†’ (0,1), (1,2) ìˆœíšŒ
        for src, dst in zip(row, col):
            """
            í•µì‹¬ ì—°ì‚° í•´ë¶€:

            out[dst] += x[src] * deg_inv[dst]
            â†‘        â†‘  â†‘       â†‘
            |        |  |       â””â”€ dst ë…¸ë“œì˜ ì´ì›ƒ ìˆ˜ ì—­ìˆ˜ (1/ì´ì›ƒìˆ˜)
            |        |  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ src ë…¸ë“œì˜ íŠ¹ì„± ë²¡í„°
            |        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê¸°ì¡´ ê°’ì— ë”í•¨ (ëˆ„ì )
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ dst ë…¸ë“œì˜ ìƒˆ íŠ¹ì„±

            ì˜ë¯¸: "src ë…¸ë“œê°€ dst ë…¸ë“œì—ê²Œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ë‹¤"

            êµ¬ì²´ì  ì˜ˆì‹œ:
                x[0] = [0.9, 0.1]  (ë…¸ë“œ 0ì˜ íŠ¹ì„±)
                deg_inv[1] = 1.0   (ë…¸ë“œ 1ì˜ ì´ì›ƒ ìˆ˜ ì—­ìˆ˜)

                out[1] += [0.9, 0.1] * 1.0
                       = [0.9, 0.1]

                í•´ì„: ë…¸ë“œ 1ì€ ë…¸ë“œ 0ì˜ ì •ë³´ [0.9, 0.1]ì„ ë°›ì•˜ë‹¤!

            += ì—°ì‚°ì„ ì“°ëŠ” ì´ìœ :
                ë§Œì•½ ë…¸ë“œ 1ì´ ì—¬ëŸ¬ ì´ì›ƒ(0, 2, 3)ì„ ê°€ì§€ë©´
                out[1] += x[0] * deg_inv[1]  # ì²« ë²ˆì§¸ ì´ì›ƒ
                out[1] += x[2] * deg_inv[1]  # ë‘ ë²ˆì§¸ ì´ì›ƒ
                out[1] += x[3] * deg_inv[1]  # ì„¸ ë²ˆì§¸ ì´ì›ƒ
                â†’ ëª¨ë“  ì´ì›ƒì˜ ì •ë³´ë¥¼ ëˆ„ì í•´ì„œ ë”í•¨!
            """
            # src ë…¸ë“œì˜ íŠ¹ì„±ì„ dst ë…¸ë“œì— ì „ë‹¬
            # deg_inv[dst]ë¥¼ ê³±í•´ì„œ í‰ê·  ê³„ì‚° (ì´ì›ƒ ìˆ˜ë¡œ ë‚˜ëˆ”)
            out[dst] += x[src] * deg_inv[dst]

        # ê° ë…¸ë“œëŠ” ì´ì›ƒë“¤ì˜ í‰ê·  íŠ¹ì„±ì„ ê°–ê²Œ ë¨
        # ì™œ í‰ê· ? deg_invê°€ 1/ì´ì›ƒìˆ˜ì´ë¯€ë¡œ ìë™ìœ¼ë¡œ í‰ê· ì´ ë¨
        # ì˜ˆ: ì´ì›ƒ 3ê°œë©´ ê°ê° 1/3ì”© ê³±í•´ì„œ ë”í•¨ â†’ í‰ê· !
        return out


class GCN(nn.Module):
    """
    PyTorch Geometric ì‚¬ìš©
    SimpleGNNê³¼ ë™ì¼í•œ ê²°ê³¼ë¥¼ ë‚´ì•¼ í•¨
    ì°¨ì´ì : ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì œê³µí•˜ëŠ” ìµœì í™”ëœ GCNConv ì‚¬ìš©
    """

    def __init__(self, in_channels, hidden_channels, out_channels):
        """
        Q: ì™œ __init__ì—ì„œ ë ˆì´ì–´ë¥¼ ì´ˆê¸°í™”í•˜ë‚˜?
        A: PyTorch íŒ¨í„´ - í•™ìŠµ ê°€ëŠ¥í•œ ê°€ì¤‘ì¹˜ íŒŒë¼ë¯¸í„°ëŠ” __init__ì—ì„œ ìƒì„±í•´ì•¼ í•¨
           (model.parameters()ë¡œ ì°¾ì„ ìˆ˜ ìˆë„ë¡)

        Q: ì™œ ë ˆì´ì–´ë¥¼ 2ê°œ ë§Œë“œë‚˜?
        A: 2-layer = 2-hop ì´ì›ƒê¹Œì§€ ì •ë³´ ë„ë‹¬ (Coraì—ì„œ ê²½í—˜ì ìœ¼ë¡œ ìµœì )
           í•˜ì§€ë§Œ ë°ì´í„°ë§ˆë‹¤ ë‹¤ë¦„! 1, 3, 4-layer ë“± ì‹¤í—˜ í•„ìš” (í•˜ì´í¼íŒŒë¼ë¯¸í„°)
        """
        # ë¶€ëª¨ í´ë˜ìŠ¤ ì´ˆê¸°í™”
        super().__init__()

        # PyGì˜ GCNConv ì‚¬ìš© - SimpleGNNì˜ aggregate í•¨ìˆ˜ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•œ ë²„ì „
        # ë‚´ë¶€ì ìœ¼ë¡œ í–‰ë ¬ ê³±ì…ˆìœ¼ë¡œ ìµœì í™”ë˜ì–´ ìˆì–´ í›¨ì”¬ ë¹ ë¦„
        self.conv1 = GCNConv(in_channels, hidden_channels)

        # ë‘ ë²ˆì§¸ GCN ë ˆì´ì–´
        self.conv2 = GCNConv(hidden_channels, out_channels)

    def forward(self, x, edge_index):
        """
        Q: ì™œ forwardì—ì„œ ì¡°ë¦½í•˜ë‚˜?
        A: ì‹¤ì œ ë°ì´í„° íë¦„ì„ ì •ì˜ - ê°™ì€ ë ˆì´ì–´ë¥¼ ë‹¤ë¥¸ ìˆœì„œë¡œ ì¡°í•© ê°€ëŠ¥ (ìœ ì—°ì„±)

        Q: ì™œ ReLUë¥¼ ì¤‘ê°„ì—ë§Œ ë„£ë‚˜?
        A: 1) ë¹„ì„ í˜•ì„± ì¶”ê°€ - ReLU ì—†ìœ¼ë©´ 2-layerê°€ 1-layerì™€ ë™ì¼í•´ì§
           2) ë§ˆì§€ë§‰ ì¶œë ¥ì€ ìŒìˆ˜ë„ í•„ìš” - CrossEntropyLossê°€ ìŒìˆ˜ ì ìˆ˜ë„ ì‚¬ìš©
        """
        # ì²« ë²ˆì§¸ GCN ë ˆì´ì–´ - íŠ¹ì„± ë³€í™˜ + ì´ì›ƒ ì§‘ê³„ë¥¼ í•œ ë²ˆì— ìˆ˜í–‰
        x = self.conv1(x, edge_index)

        # ReLU í™œì„±í™” í•¨ìˆ˜ - ì¤‘ê°„ì—ë§Œ! (ë¹„ì„ í˜•ì„± ì¶”ê°€)
        # ìŒìˆ˜ë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ì–´ì„œ ë¹„ì„ í˜• ë³€í™˜
        # ì˜ˆ: [-0.3, 0.8, -0.1, 0.5] â†’ [0, 0.8, 0, 0.5]
        x = torch.relu(x)

        # ë‘ ë²ˆì§¸ GCN ë ˆì´ì–´
        x = self.conv2(x, edge_index)

        # ì¶œë ¥ ë°˜í™˜ - ë§ˆì§€ë§‰ì€ ReLU ì—†ìŒ! (ìŒìˆ˜ ì ìˆ˜ë„ ì˜ë¯¸ìˆìŒ)
        # ì™œ ë§ˆì§€ë§‰ì—ëŠ” ReLUë¥¼ ì•ˆ ë„£ë‚˜?
        # 1) CrossEntropyLossëŠ” ìŒìˆ˜ ë¡œì§“ë„ í•„ìš”í•¨
        #    ì˜ˆ: [5.2, -1.3, 0.8, -0.5, 2.1, -2.0, 0.3]
        #        â†’ -1.3ì€ "ìƒë¬¼í•™ ì•„ë‹˜"ì„ ì˜ë¯¸ (ì¤‘ìš”í•œ ì •ë³´!)
        #        â†’ ReLUë¥¼ ì“°ë©´ [5.2, 0, 0.8, 0, 2.1, 0, 0.3]
        #        â†’ ìŒìˆ˜ ì •ë³´ ì†ì‹¤! ëª¨ë¸ ì„±ëŠ¥ ì €í•˜!
        #
        # 2) Softmaxê°€ ë‚´ë¶€ì ìœ¼ë¡œ ìŒìˆ˜ë¥¼ ì²˜ë¦¬í•¨
        #    exp(-1.3) = 0.27 (ì‘ì€ í™•ë¥ ) â† ìŒìˆ˜ë„ ìœ íš¨í•œ ì…ë ¥
        #
        # ê²°ë¡ : ì¤‘ê°„ ë ˆì´ì–´ëŠ” ReLUë¡œ ë¹„ì„ í˜•ì„± ì¶”ê°€,
        #      ë§ˆì§€ë§‰ ì¶œë ¥ì€ ì›ì‹œ ì ìˆ˜(logits)ë¡œ ìœ ì§€!
        return x


def train_gnn(model_class, model_name="GNN"):
    """
    Cora ë°ì´í„°ì…‹: ë…¼ë¬¸ ì¸ìš© ê·¸ë˜í”„
    - 2708ê°œ ë…¼ë¬¸ (nodes)
    - 5429ê°œ ì¸ìš© ê´€ê³„ (edges)
    - 7ê°œ ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜

    ëª©í‘œ: 85% ì´ìƒ test accuracy
    """

    # === ë°ì´í„° ë¡œë“œ ===

    # Cora ë°ì´í„°ì…‹ ë‹¤ìš´ë¡œë“œ ë° ë¡œë“œ (ë…¼ë¬¸ ë¶„ë¥˜ ë°ì´í„°)
    # root: ë°ì´í„°ë¥¼ ì €ì¥í•  í´ë”
    dataset = Planetoid(root='./data', name='Cora')

    # ì²« ë²ˆì§¸ (ê·¸ë¦¬ê³  ìœ ì¼í•œ) ê·¸ë˜í”„ ê°€ì ¸ì˜¤ê¸°
    # dataì—ëŠ” x(íŠ¹ì„±), edge_index(ê·¸ë˜í”„ êµ¬ì¡°), y(ë¼ë²¨) ë“±ì´ í¬í•¨ë¨
    data = dataset[0]

    # === ë°ì´í„°ì…‹ ì •ë³´ ì¶œë ¥ ===

    print(f"\n{'='*60}")
    print(f"Training {model_name}")
    print(f"{'='*60}")
    print("Dataset Statistics:")

    # ì´ ë…¸ë“œ(ë…¼ë¬¸) ê°œìˆ˜
    print(f"Nodes: {data.num_nodes}")

    # ì´ ì—£ì§€(ì¸ìš© ê´€ê³„) ê°œìˆ˜
    print(f"Edges: {data.num_edges}")

    # ê° ë…¸ë“œì˜ íŠ¹ì„± ì°¨ì› (ë‹¨ì–´ ë¹ˆë„ ë²¡í„° í¬ê¸°)
    print(f"Features: {data.num_node_features}")

    # ë¶„ë¥˜í•  í´ë˜ìŠ¤(ì¹´í…Œê³ ë¦¬) ê°œìˆ˜
    print(f"Classes: {dataset.num_classes}")

    # í•™ìŠµ ì…‹ í¬ê¸° - í•™ìŠµì— ì‚¬ìš©í•  ë…¸ë“œ ìˆ˜
    print(f"Train mask: {data.train_mask.sum().item()}")

    # ê²€ì¦ ì…‹ í¬ê¸° - í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹ìš©
    print(f"Val mask: {data.val_mask.sum().item()}")

    # í…ŒìŠ¤íŠ¸ ì…‹ í¬ê¸° - ìµœì¢… ì„±ëŠ¥ í‰ê°€ìš©
    print(f"Test mask: {data.test_mask.sum().item()}")

    # === ëª¨ë¸ ì´ˆê¸°í™” ===

    # ëª¨ë¸ ìƒì„± (SimpleGNN ë˜ëŠ” GCN)
    model = model_class(
        in_channels=dataset.num_node_features,  # ì…ë ¥ íŠ¹ì„± ì°¨ì› (1433)
        hidden_channels=16,  # ì€ë‹‰ì¸µ í¬ê¸° (í•˜ì´í¼íŒŒë¼ë¯¸í„°)
        out_channels=dataset.num_classes  # ì¶œë ¥ í´ë˜ìŠ¤ ìˆ˜ (7)
    )

    # === ìµœì í™” ì„¤ì • ===

    # Adam ì˜µí‹°ë§ˆì´ì € - í•™ìŠµ ì¤‘ ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸ë¥¼ ë‹´ë‹¹
    # lr: learning rate (í•™ìŠµë¥ ) - ì–¼ë§ˆë‚˜ í¬ê²Œ ê°€ì¤‘ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í• ì§€
    # weight_decay: L2 regularization - ê³¼ì í•© ë°©ì§€ (ê°€ì¤‘ì¹˜ê°€ ë„ˆë¬´ ì»¤ì§€ëŠ” ê²ƒ ë°©ì§€)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)

    # CrossEntropyLoss: ë‹¤ì¤‘ í´ë˜ìŠ¤ ë¶„ë¥˜ë¥¼ ìœ„í•œ ì†ì‹¤ í•¨ìˆ˜
    # ëª¨ë¸ì˜ ì˜ˆì¸¡ê³¼ ì‹¤ì œ ë¼ë²¨ ê°„ì˜ ì°¨ì´ë¥¼ ê³„ì‚°
    # ì‘ë™ ì›ë¦¬: Loss = -log(ì •ë‹µ ì¹´í…Œê³ ë¦¬ì˜ í™•ë¥ )
    #   ì˜ˆì¸¡ ì˜í•¨: í™•ë¥  0.9 â†’ Loss = -log(0.9) = 0.105 (ì‘ìŒ)
    #   ì˜ˆì¸¡ í‹€ë¦¼: í™•ë¥  0.1 â†’ Loss = -log(0.1) = 2.303 (í¼)
    criterion = nn.CrossEntropyLoss()

    # === í•™ìŠµ ë£¨í”„ ===

    # í•™ìŠµ ëª¨ë“œë¡œ ì„¤ì • - Dropout ë“±ì„ í™œì„±í™”
    model.train()

    # 200ë²ˆì˜ ì—í­(ì „ì²´ ë°ì´í„°ë¥¼ 200ë²ˆ ë°˜ë³µ í•™ìŠµ)
    for epoch in range(200):
        # Step 1: ê¸°ìš¸ê¸°(gradient) ì´ˆê¸°í™”
        # ì´ì „ ì—í­ì˜ ê¸°ìš¸ê¸°ê°€ ëˆ„ì ë˜ì§€ ì•Šë„ë¡ 0ìœ¼ë¡œ ë¦¬ì…‹
        optimizer.zero_grad()

        # Step 2: ìˆœì „íŒŒ (Forward pass)
        # ëª¨ë¸ì— ê·¸ë˜í”„ ì „ì²´ë¥¼ ì…ë ¥í•´ì„œ ì˜ˆì¸¡ê°’ ê³„ì‚°
        out = model(data.x, data.edge_index)

        # Step 3: ì†ì‹¤ ê³„ì‚°
        # í•™ìŠµ ì…‹ì— í•´ë‹¹í•˜ëŠ” ë…¸ë“œë“¤ë§Œ ì‚¬ìš©í•´ì„œ ì†ì‹¤ ê³„ì‚°
        # train_maskë¡œ í•™ìŠµ ë…¸ë“œë§Œ ì„ íƒ
        loss = criterion(out[data.train_mask], data.y[data.train_mask])

        # Step 4: ì—­ì „íŒŒ (Backward pass)
        # ì†ì‹¤ì„ ê¸°ë°˜ìœ¼ë¡œ ê° íŒŒë¼ë¯¸í„°ì˜ ê¸°ìš¸ê¸° ê³„ì‚°
        loss.backward()

        # Step 5: ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸
        # ê³„ì‚°ëœ ê¸°ìš¸ê¸°ë¥¼ ì‚¬ìš©í•´ íŒŒë¼ë¯¸í„° ê°±ì‹ 
        optimizer.step()

        # === 20 ì—í­ë§ˆë‹¤ ê²€ì¦ ===
        if (epoch + 1) % 20 == 0:
            # í‰ê°€ ëª¨ë“œë¡œ ì „í™˜ - Dropout ë“±ì„ ë¹„í™œì„±í™”
            model.eval()

            # ê¸°ìš¸ê¸° ê³„ì‚° ì—†ì´ ì˜ˆì¸¡ë§Œ ìˆ˜í–‰ (ë©”ëª¨ë¦¬ ì ˆì•½, ì†ë„ í–¥ìƒ)
            with torch.no_grad():
                # ì „ì²´ ê·¸ë˜í”„ì— ëŒ€í•´ ì˜ˆì¸¡
                pred = model(data.x, data.edge_index).argmax(dim=1)

                # í•™ìŠµ ì…‹ ì •í™•ë„ ê³„ì‚°
                train_acc = (pred[data.train_mask] == data.y[data.train_mask]).float().mean()

                # ê²€ì¦ ì…‹ ì •í™•ë„ ê³„ì‚° (ê³¼ì í•© í™•ì¸ìš©)
                val_acc = (pred[data.val_mask] == data.y[data.val_mask]).float().mean()

            # ë‹¤ì‹œ í•™ìŠµ ëª¨ë“œë¡œ ì „í™˜
            model.train()

            # í˜„ì¬ ì—í­ì˜ ì„±ëŠ¥ ì¶œë ¥
            print(f'Epoch {epoch+1:03d}, Loss: {loss:.4f}, '
                  f'Train Acc: {train_acc:.4f}, Val Acc: {val_acc:.4f}')

    # === ìµœì¢… í…ŒìŠ¤íŠ¸ (í•™ìŠµ ì™„ë£Œ í›„) ===

    # í‰ê°€ ëª¨ë“œë¡œ ì „í™˜
    model.eval()

    # ê¸°ìš¸ê¸° ê³„ì‚° ë¹„í™œì„±í™”
    with torch.no_grad():
        # ì „ì²´ ê·¸ë˜í”„ ì˜ˆì¸¡
        pred = model(data.x, data.edge_index).argmax(dim=1)

        # í…ŒìŠ¤íŠ¸ ì…‹ ì •í™•ë„ ê³„ì‚° (í•œ ë²ˆë„ í•™ìŠµì— ì‚¬ìš©ë˜ì§€ ì•Šì€ ë…¸ë“œ)
        # ì´ ê°’ì´ ëª¨ë¸ì˜ ì§„ì§œ ì„±ëŠ¥!
        test_acc = (pred[data.test_mask] == data.y[data.test_mask]).float().mean()

    # ìµœì¢… ê²°ê³¼ ì¶œë ¥
    print(f'\nFinal Test Accuracy: {test_acc:.4f}')
    print(f"{'='*60}\n")

    # í•™ìŠµëœ ëª¨ë¸, ë°ì´í„°, í…ŒìŠ¤íŠ¸ ì •í™•ë„ ë°˜í™˜
    return model, data, test_acc


if __name__ == "__main__":
    # === ë©”ì¸ ì‹¤í–‰ ë¸”ë¡ ===
    # ì´ íŒŒì¼ì„ ì§ì ‘ ì‹¤í–‰í•  ë•Œë§Œ ì•„ë˜ ì½”ë“œê°€ ì‹¤í–‰ë¨ (import ì‹œì—ëŠ” ì‹¤í–‰ ì•ˆë¨)

    print("\nğŸš€ Starting GNN Training on Cora Dataset")
    print("="*60)

    # === 1. SimpleGNN í•™ìŠµ (ì²˜ìŒë¶€í„° ì§ì ‘ êµ¬í˜„í•œ ë²„ì „) ===
    print("\n1ï¸âƒ£  Training SimpleGNN (from scratch implementation)")
    # train_gnn í•¨ìˆ˜ í˜¸ì¶œ - SimpleGNN í´ë˜ìŠ¤ ì „ë‹¬
    simple_model, data, simple_acc = train_gnn(SimpleGNN, "SimpleGNN")

    # === 2. PyTorch Geometric GCN í•™ìŠµ (ë¼ì´ë¸ŒëŸ¬ë¦¬ ë²„ì „) ===
    print("\n2ï¸âƒ£  Training PyTorch Geometric GCN")
    # ë™ì¼í•œ ë°ì´í„°ë¡œ PyGì˜ GCN í•™ìŠµ
    # dataëŠ” ì´ë¯¸ ë°›ì•˜ìœ¼ë¯€ë¡œ _ë¡œ ë¬´ì‹œ
    gcn_model, _, gcn_acc = train_gnn(GCN, "PyTorch Geometric GCN")

    # === ê²°ê³¼ ë¹„êµ ===
    print("\n" + "="*60)
    print("ğŸ“Š Final Results Summary")
    print("="*60)

    # ë‘ ëª¨ë¸ì˜ í…ŒìŠ¤íŠ¸ ì •í™•ë„ ë¹„êµ
    print(f"SimpleGNN Test Accuracy: {simple_acc:.4f}")
    print(f"PyG GCN Test Accuracy:   {gcn_acc:.4f}")

    # ë‘ ëª¨ë¸ì˜ ì°¨ì´ - ì´ë¡ ì ìœ¼ë¡œëŠ” ê±°ì˜ ê°™ì•„ì•¼ í•¨
    print(f"Difference:              {abs(simple_acc - gcn_acc):.4f}")

    # === ëª©í‘œ ë‹¬ì„± ì—¬ë¶€ í™•ì¸ ===
    if simple_acc >= 0.85 or gcn_acc >= 0.85:
        # 85% ì´ìƒì´ë©´ ì„±ê³µ!
        print("\nâœ… Success! Achieved 85%+ test accuracy goal!")
    else:
        # 85% ë¯¸ë§Œì´ë©´ í•˜ì´í¼íŒŒë¼ë¯¸í„° ì¡°ì • ê¶Œì¥
        print("\nâš ï¸  Close! Try adjusting hyperparameters for better results.")

    print("="*60)
